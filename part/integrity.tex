\section{Механизмы обеспечения целостности СУБД}

\subsection{Угрозы целостности СУБД}
Задача обеспечения целостности предусматривает комплекс мер по предотвращению как непреднамеренного, так и преднамеренного изменения или уничтожения информации, используемой информационной системой управления или системой поддержки принятия решений. Изменение или уничтожение данных может быть следствием неблагоприятного стечения обстоятельств и состояния внешней среды (стихийные бедствия, пожары и т. п.), аппаратных или программных сбоев (отказ дисковой системы, нарушение целостности файлов БД, ошибки ПО), а также неадекватных действий пользователей (ошибки при вводе данных, ошибки операторов и т. п.) и проблем, возникающих при некорректной организации многопользовательской обработки данных, таких как некорректное управление конкурентным доступом, отсутствие механизмов блокировки и контроля изоляции транзакций. \autocite{Lihonosov2011, postgredoc1}.

Кроме того, угрозу целостности представляют преднамеренные атаки, например: SQL-инъекции, модификация данных привилегированными пользователями, эксплуатация уязвимостей в механизмах контроля доступа. Целостность данных также может быть нарушена в результате физического повреждения носителей информации (износ SSD/HDD, сбои в RAID-массивах, ошибки в системе хранения).

Например, при отсутствии механизмов контроля доступа, с помощью SQL-операторов UPDATE, INSERT и DELETE, злоумышленник или просто неопытный пользователь могут изменить данные в СУБД. Опасность заключается в том, что, при отсутствии принципа минимально необходимых привилегий, пользователь может получить возможность модифицировать все записи в таблице.  \autocite{Utebov2008, nist80012}.

\paragraph{Основные виды и причины возникновения угроз целостности} ~\\

Нарушение целостности информационной системы может произойти по разным причинам (включая технические сбои, ошибки конфигурирования, неправильные действия пользователя, преднамеренные атаки), и некоторые из этих причин могут также приводить и к нарушению доступности информации. 
Эти факторы можно разделить на внутренние (возникающие в рещультате ошибок эксплуатации или ПО) и внешние (обусловлинные воздействием окружающего мира, злоумышленников, технических сбоев).

\begin{enumerate}
\item \textbf{Внутренние угрозы целостности ИС}.
    \begin{itemize}
        \item Случайное или умышленное отступление от правил эксплуатации. Например, правила могут предусматривать определенный набор параметров сервера (объем памяти, производительность процессора, объем дискового пространства, версия операционной системы и т.п.), на котором предполагается использовать ИС. Сюда же можно отнести, например, некорректную настройку резервного копирования или преднамеренное отключение логирования.;
        \item Ошибки конфигурирования системы на этапах установки, обновления, эксплуатации. Например, неправильное (необдуманное) управление правами доступа, незащищенные сетевые интерфейсы и т.д.;
        \item Отказ программного обеспечения. Может быть вызван ошибками разработки, какими-то некорректными обновлениями, ну или преднамеренными изменениями кода (например, внедрение вредоносного ПО)
	\item Проблемы управления многопользовательским доступом (состояния гонки, deadlock-ситуации, аномалии уровнеий изоляции транзакций)
    \end{itemize}

\item \textbf{Внешние угрозы целостности ИС}.
    \begin{itemize}
        \item Нарушение условий работы ИС, вызванные сбоями облачных сервисов и/или являющееся следствием зависимости от сторонних провайдеров (проблемы с системами связи, отключения электропитания, отопления и т.п.).
        \item Разрушение или повреждение помещений, связанное с природными катаклизмами. Конечно, такая ситуация на первый взгляд кажется мало возможной, но это вполне вероятно в регионах, например, с сейсмической неустойчивостью (привет Камчатке).
        \item Разрушение информации преднамеренными действиями злоумышленников или инсайдеров.
        \item Сетевые атаки, вредоносные программы (к примеру, шифровальщики, модифицирующие данные), SQL-инъекции, атаки на механизмы репликации и т.д.
	\item Эксплуатация уязвимостей в СУБД, физический доступ к оборудованию.
    \end{itemize}
\end{enumerate}

\paragraph{Способы противодействия} ~\\

Основными средствами защиты целостности информации в ИС являются \autocite{Pirogov2009}:
\begin{itemize}
    \item Транзакционные механизмы, позволяющие восстановить целостность данных в случае незначительных сбоев, ACID-свойства. \autocite{worksol1, DBtest};
    \item Контроль целостности на уровне базы данных. Реализация CHECK, FOREIGN KEY, NOT NULL и триггеров, предтовращающих некорректное изменение данных. \autocite{flenovinfo};
    \item Использование WAL (Write-Ahead Logging) - позволят сохранить изменение перед его внесением в основную базу. То есть проще сделать откат транзакции и восстановление данных. \autocite{WALintro};
    \item Резервное копирование данных. Использование PITR (point-in-time recovery), географически распределеная репликация на случай какого-то серьезного сбоя, \autocite{PITRintro};
    \item Периодическое тестирование системы на предмет нарушения целостности, анализ логов БД, а также использование IDS с целью попыток выявления попыток несанкционированного изменения данных \autocite{DBtest}.
    \item Использование отказоустойчивых серверов, UPS (системы бесперебойного питания), аппаратных средств шифрования, осуществление контроля доступа к серверному оборудованию \autocite{tolerance1, tolerance2}.

\end{itemize}

\subsection{Метаданные и словарь данных}

\begin{grayquote}
	\textbf{Метаданные} -- Это данные, описывающие другие данные. Это важный элемент хранилища данных, который предоставляет возможность показывать пользователю предметно-ориентированную структуру, а не набор абстрактно-связанных таблиц. Метаданные предназначены для хранения информации о происхождении данных, о любых изменениях данных, о расположении данных, об ограничениях на данные, о соответствии данных тем или иным объектам предметной области и т. д. \autocite{Pirogov2009}
\end{grayquote}

Говоря более простым языком: 
Если \textbf{данные} — то, что хранится в базе данных приложения (данные о клиентах, пользователях, заказах и т.п.), то \textbf{метаданные} — это описание структуры данных. Описание того, какие типы объектов хранятся в базе данных, какие у них есть поля (атрибуты, элементы), описание зависимостей между объектами. В общем случает типы могут наследовать атрибуты родительского типа, а один атрибут в общем случае может присутствовать у двух и более типов, несвязанных отношением наследования \autocite{Metadatahabr}.

\subsubsection{Назначение словаря данных} ~\\

Согласно реляционной модели данных, информация о структуре базы данных должна храниться в самой базе данных, в виде специальных таблиц. Это требование описано в 4-м правиле Кодда (Dynamic On-Line Catalog Based on the Relational Model), согласно которому СУБД должна автоматически управлять метаданными и обеспечивать их доступность через стандартные средства запросов.

Для организации хранения метаданных в реляционных СУБД используются системные каталоги, которые также называют "словари данных".

\begin{grayquote}
    \textbf{Системный каталог} — это совокупность специальных таблиц, автоматически создаваемых и управляемых самой СУБД. Он содержит информацию о структуре базы данных, включая перечень таблиц, индексов, ограничений целостности, а также сведения о пользователях, их привилегиях и других параметрах системы \autocite{IntuitLec14}.
\end{grayquote}

Системные каталоги со временем развивались. Первые реализации каталогов появились еще в 1970-х годах в исследовательских проектах \textbf{IBM System R} и \textbf{Ingres}, но формально описание системного каталога было включено в стандарт \textbf{SQL-86}. В нем задавались базовые требования к хранению метаданных, но без единого формата их представления \autocite{DictHist}.

В \textbf{SQL-92} была стандартизирована структура системного каталога, а точнее представления, объединенные в схему \texttt{INFORMATION\_SCHEMA}. Эта штука в какой-то степени развязала руки разработчикам писать универсальные запросы для получения информации о таблицах, индексах, ограничениях и других объектах БД вне зависимости от конкретной СУБД. Однако на момент принятия стандарта, многие СУБД уже использовали собственные форматы каталогов, и их переход на \texttt{INFORMATION\_SCHEMA} оказался затруднительным.

\subsubsection{Реализация системных каталогов в разных СУБД}

Реализация и организация системных каталогов отличаются в зависимости от СУБД.

\begin{enumerate}
    \item \textbf{PostgreSQL}. \autocite{PostgreSQLdocc51,HabrDataOrgp1,YTcoursepostgre}
    
    В PostgreSQL системный каталог — это набор таблиц и представлений, содержащих метаданные обо всех объектах базы данных. Эти таблицы расположены в схеме \texttt{pg\_catalog}, которая по умолчанию включена в путь поиска. То есть можно обращаться к таблицам без явного указания схемы. Примеры таких таблиц: \texttt{pg\_class} (информация о таблицах и представлениях), \texttt{pg\_attribute} (сведения о столбцах) и \texttt{pg\_index} (данные об индексах). \autocite{PostgreSQLdocc51}

    Хотя системные каталоги и являются обычными таблицами, их прямое изменение не рекомендуется, так как это может привести к некорректной работе системы. Для внесения изменений рекомендуется использовать соответствующие SQL-команды, такие как \texttt{CREATE TABLE}, которая автоматически обновляет соответствующие записи в системном каталоге.

    Для получения информации из системного каталога рекомендуется использовать стандартные представления, наподобие \texttt{information\_schema}.

    Подробную информацию о системных каталогах PostgreSQL можно найти в официальной документации. \autocite{PostgreSQLdocc51}

    \item \textbf{MySQL}.
    
    В MySQL метаданные о базах данных и их объектах хранятся в специальной базе данных под названием \texttt{information\_schema}. Эта база данных содержит набор представлений, предоставляющих информацию о структурах баз данных (таблицах, столбцах, индексах, привилегиях пользователей).

    Например, представление \texttt{TABLES} в \texttt{information\_schema} содержит информацию обо всех таблицах, их имена, типы и используемые механизмы хранения. Представление \texttt{COLUMNS} дает сведения о столбцах таблиц (имена, типы данных и дополнительные характеристики).

    Доступ к данным в \texttt{information\_schema} осуществляется с помощью стандартных SQL-запросов. Например, получить список всех таблиц в определенной базе данных можно следующим запросом:

    \begin{lstlisting}[language=SQL]
    SELECT table_name
    FROM information_schema.tables
    WHERE table_schema = 'DATABASE_NAME';
    \end{lstlisting}

    Подробную информацию о структуре и содержимом \texttt{information\_schema} можно найти в официальной документации MySQL. \autocite{Mysqldoc1}
    
    Также стоит отметить, что в MySQL физическое хранение данных организовано в виде файловой системы, где каждая база данных представлена как подкаталог в основном каталоге данных сервера. Внутри каждого подкаталога файлы соответствуют таблицам и другим объектам базы данных. \autocite{IntuitMySQLadm}

    \item \textbf{Microsoft SQL Server}. \autocite{MicrosoftLearnSQLserver,professorweb,HabrTsql}

    В Microsoft SQL Server метаданные обо всех объектах базы данных хранятся в системных представлениях каталога, расположенных в схеме \texttt{sys}. Информация этих представлений содержит данные о таблицах, представлениях, столбцах, индексах, ограничениях и прочих объектах БД. Использование системных представлений позволяет администраторам и разработчикам получать структурированную информацию о состоянии БД и её объектах.
    
    \subparagraph{Основные представления каталога} ~\\
    
    Примеры наиболее часто используемых представлений:
    
    \begin{itemize}
        \item \texttt{sys.tables} — информация о всех таблицах в БД (имена, идентификаторы, даты создания);
        \item \texttt{sys.columns} — сведения о столбцах таблиц (имена, типы данных, порядковые номера);
        \item \texttt{sys.indexes} — информация об индексах (типы индексов, их назначение);
        \item \texttt{sys.foreign\_keys} — сведения о внешних ключах (ограничения ссылочной целостности);
        \item \texttt{sys.database\_principals} — информация о пользователях БД.
    \end{itemize}
    
    \subparagraph{Примеры запросов к системным представлениям} ~\\
    
    Для получения списка всех таблиц в текущей БД используется SQL-запрос:
    
    \begin{lstlisting}[language=SQL]
    SELECT name 
    FROM sys.tables;
    \end{lstlisting}
    
    Если необходимо получить список всех столбцов конкретной таблицы:
    
    \begin{lstlisting}[language=SQL]
    SELECT column_name, data_type, is_nullable
    FROM information_schema.columns
    WHERE table_name = 'Employees';
    \end{lstlisting}
    
    Для просмотра индексов таблицы:
    
    \begin{lstlisting}[language=SQL]
    SELECT i.name AS IndexName, t.name AS TableName
    FROM sys.indexes i
    JOIN sys.tables t ON i.object_id = t.object_id
    WHERE t.name = 'Employees';
    \end{lstlisting}
    
    \subparagraph{Рекомендации по использованию} ~\\
    
    Рекомендуется использовать системные представления каталога вместо прямого доступа к системным таблицам, так как представления:
    
    \begin{itemize}
        \item предоставляют стандартизированный интерфейс для получения метаданных;
        \item обеспечивают обратную совместимость при обновлении версий SQL Server;
        \item позволяют получать данные в удобном формате без необходимости разбираться во внутренней структуре системы.
    \end{itemize}

    \item \textbf{Oracle}.

    В Oracle Database словарь данных состоит из нескольких наборов представлений. Во многих случаях такой набор состоит из трех представлений, содержащих аналогичную информацию и отличающихся друг от друга своими префиксами \autocite{Kirillov2009}.\\

    Словарь данных базы данных Oracle имеет два основных применения:
    \begin{itemize}
        \item Oracle обращается к словарю данных каждый раз, когда выполняются команды языка DDL (Data Definition Language), например \texttt{CREATE TABLE}, \texttt{ALTER TABLE}, \texttt{DROP TABLE} и тд. Например, при создании таблицы Oracle вносить соответвсуюшую запись в \texttt{DBA\_TABLES} и \texttt{ALL\_TABLES}.
        \item каждый пользователь Oracle может обращаться к словарю данных как к справочнику со сведениями по базе данных (доступные объекты). Нпример DBA может юзать словарь данныхх для мониторинга структуры схемы или например анализа привилегий юзеров
    \end{itemize}

    При этом словарь данных всегда доступен при открытой базе данных. Он размещается в табличном пространстве SYSTEM, которое всегда находится в состоянии Online, когда база данных открыта.

    Основные категории представлений \autocite{oracledbdoc1}:
    \begin{enumerate}

        \item \textbf{Представления с префиксом \texttt{USER\_}} содержат информацию об объектах, принадлежащих текущему пользователю. Напирмер \texttt{USER\_TABLES} отображает таблицы, созданные текущим пользователем, а \texttt{USER\_TAB\_COLUMNS} даст инфу о столбцах тааблиц пользователя.
        Пример запроса:
        \begin{lstlisting}[language=SQL]
        SELECT table_name 
        FROM user_tables;
        \end{lstlisting}

        \item \textbf{Представления с префиксом \texttt{ALL\_}} предоставляют информацию обо всех объектах, к которым текущий пользователь имеет доступ, независимо от владельца. Например \texttt{ALL\_TABLES} показывает все таблицы, доступные пользователю. \texttt{ALL\_TAB\_COLUMNS} показывает информацию о столбцах всех доступнх таблиц.
        Пример запроса:
        \begin{lstlisting}[language=SQL]
        SELECT table_name 
        FROM all_tables 
        WHERE owner = 'HR';
        \end{lstlisting}

        \item \textbf{Представления с префиксом \texttt{DBA\_}} содержат информацию обо всех объектах в БД и доступны только пользователям с соответствующими привилегиями (типа админ). К примеру \texttt{DBA\_TABLES} предоставляет список всех таблиц в БД, \texttt{DBA\_USERS} - информациб обо всех пользователях БД.
        Пример запроса:
        \begin{lstlisting}[language=SQL]
        SELECT username 
        FROM dba_users;
        \end{lstlisting}

    \end{enumerate}

    Столбцы в представленях с префиксами \texttt{USER\_}, \texttt{ALL\_}, \texttt{DBA\_} идентичны, но есть нюанс. Объем данных возвращаемых каждый представлением зависит от прав доступа пользователя. В представлениях \texttt{USER\_} к примеру обычно нет столбца \texttt{OWNER}, так как подразумевается что владелец это текущий пользователь, выдавший запрос. Некоторые представления DBA имеют дополнительные столбцы, которые содержат информацию, полезную для БД.

    \textbf{Динамические представления происзводительности \texttt{V\textdollar}}. \autocite{oracledbdoc2}

    Помимо статических представлений словаря данных, Oracle предоставляет Dynamic Performance Views, также извесные как \texttt{V\textdollar}-представления. Они содержат информацию о текущем состоянии БД и её производительности. Они обновляются в реальном времени и позволяют отслеживать активность системы, типа там текущие сессии, параметры, статистику производительности и тд. То есть используются они для мониторинга активности БД в рельном времени.

    Как пример можно привести \texttt{V\textdollar SESSION} (информация о текущих подключенных сессиях) или \texttt{V\textdollar PARAMETER} (текущие параметры конфигурации БД).

    Пример запроса:
    \begin{lstlisting}[language=SQL]
    SELECT sid, serial#, username, status 
    FROM v$session 
    WHERE status = 'ACTIVE';
    \end{lstlisting}
    
\end{enumerate}

\subsubsection{Логическая структура словаря данных}

Логическая структура словаря данных \autocite{PostgreSQLdocc51,ElmasriNavathe,Silberschatz} включает в себя:

\begin{enumerate}
    \item Описание структуры объектов базы данных (информация о таблицах, индексах, ограничениях, связях между объектами БД)
    \item Метаданные о транзакциях (сведения о выполняемых операциях, механизах блокировок, истории SQL-запросов)
    \item Статистику работы системы (данные о производительности, статистике выполнения запросов, параметрах конфигурации СУБД)
\end{enumerate}

Далее (через страницу) последовательно будут рассмотрены каждый из этих пунктов

Также важно надо понимать разницу между \textbf{логической} и \textbf{физической} структурой словаря данных:

\begin{itemize}
    \item \textbf{Логическая структура} описывает, какие именно данные хранятся, в каком виде они представлены, как взоимосвязаны между собой
    \item \textbf{Физическая структура} (рассмотрится далее) описывает где и как хранятся данные словаря, какие файлы и таблицы используются
\end{itemize}

Словари данных могут быть \textbf{стандартные} и \textbf{вендор-зависимые}:

\begin{enumerate}
 
    \item Стандартные словари данных реализованы по международным стандартам SQL и обеспечивают SQL-запросы к словарю совместимыми между различными СУБД. Ключевой пример – схема \texttt{INFORMATION\_SCHEMA} (введенная в стандарт SQL-92). Оно поддерживается в MySQL, Microsoft SQL Server, PostgreSQL и других СУБД и позволяет разработать межплатформенные решения.

        \textbf{Пример SQL-запроса}:
        \begin{lstlisting}[language=SQL]
        SELECT table_name, column_name, data_type 
        FROM INFORMATION_SCHEMA.COLUMNS 
        WHERE table_schema = 'public';
        \end{lstlisting}

    \item Вендор-зависимые словари данных реализованы специфическими разработчиками СУБД и как правило зачастую \textbf{предоставляют расширенные возможности, недоступные в стандартных словарях}. 

    Примеры вендор-зависимых системных каталогов:
    \begin{itemize}
        \item PostgreSQL: \texttt{pg\_catalog} – содержит таблицы \texttt{pg\_tables}, \texttt{pg\_indexes}, \texttt{pg\_roles} (расширеные метаданные о структуре БД).
        \item Microsoft SQL Server: \texttt{sys.*} – набор системных представлений, включающий \texttt{sys.tables}, \texttt{sys.columns}, \texttt{sys.indexes} и другие.
        \item Oracle: \texttt{DBA\_*}, \texttt{ALL\_*}, \texttt{USER\_*} – системные представления для админов, юзеров и всех объектов бд.
    \end{itemize}

\end{enumerate}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Тип словаря} & \textbf{Пример в СУБД} & \textbf{Совместимость} \\
        \hline
        Стандартный & INFORMATION\_SCHEMA & Высокая (MySQL, SQL Server, PostgreSQL) \\
        \hline
        Вендор-зависимый & pg\_catalog (PostgreSQL) & Ограниченная (только PostgreSQL) \\
        \hline
        Вендор-зависимый & sys.* (SQL Server) & Только Microsoft SQL Server \\
        \hline
        Вендор-зависимый & DBA\_* (Oracle) & Только Oracle DB \\
        \hline
    \end{tabular}
    \caption{Стандартные и вендор-зависимые словари данных}
    \label{tab:data_dictionary_comparison}
\end{table}

Ну то есть суть в том, что использование вендор-зависимых требует всяких специфических знаний конкретной платформы.

Итак, перейдем к рассмотрению указанных ранее пунктов:

\paragraph{Основные объекты, хранящиеся в словаре данных} ~\\

\begin{enumerate}

    \item Таблицы и их атрибуты \autocites[§51.11]{PostgreSQLdocc51}[§28.3.38]{Mysqldoc1}{MicrosoftLearnSQLserver}

    Одним из основных компонентов словаря данных является информация о таблицах и их атрибутах. В реляционной модели данные организованы в виде таблиц, и их структура должна быть четко определена и документирована.

    \begin{enumerate}
        \item Метаданные о таблицах

        \begin{itemize}
            \item Название таблицы (\texttt{table\_name})
            \item Схема (пространство имен) (\texttt{schema\_name})
            \item Тип таблицы (обычная, временная, внешняя и т. д.)
            \item Дата создания и последнего изменения
            \item Физическое расположение таблицы (табличное пространство, файловая группа)
            \item Овнер таблицы (создатель)
            \item Размер таблицы (количество строк, объем занимаемого пространства на диске)
        \end{itemize}

        Пример SQL-запроса (PostgreSQL, получение информации о таблицах):
        \begin{lstlisting}[language=SQL]
        SELECT schemaname, tablename, tableowner, tablespace 
        FROM pg_tables;
        \end{lstlisting}

        Примеры расположения метаданных о таблицах в разных СУБД:
        \begin{itemize}
            \item PostgreSQL: \texttt{pg\_class}, \texttt{pg\_tables}
            \item MySQL: \texttt{INFORMATION\_SCHEMA.TABLES}
            \item SQL Server: \texttt{sys.tables}
            \item Oracle: \texttt{ALL\_TABLES}, \texttt{USER\_TABLES}, \texttt{DBA\_TABLES}
        \end{itemize}

        \item Атрибуты (столбцы) таблиц
    
        Кроме информации о таблице в целом, важно хранить сведения о ее столбцах и их свойствах:
        
        \begin{itemize}
            \item Имя столбца (\texttt{column\_name})
            \item Тип данных (\texttt{VARCHAR}, \texttt{INTEGER}, \texttt{BOOLEAN} и т. д.)
            \item Размерность данных (\texttt{length}, \texttt{precision}, \texttt{scale})
            \item Значение по умолчанию
            \item Является ли столбец автоинкрементным (\texttt{SERIAL}, \texttt{IDENTITY} и т. д.)
            \item Описание (комментарий к столбцу, если поддерживается СУБД)
        \end{itemize}

        Пример SQL-запроса (MySQL, получение информации о столбцах таблицы):
        \begin{lstlisting}[language=SQL]
        SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, IS_NULLABLE 
        FROM INFORMATION_SCHEMA.COLUMNS 
        WHERE TABLE_NAME = 'employees';
        \end{lstlisting}
    \end{enumerate}
    
    \item Индексы \autocites[§51.26]{PostgreSQLdocc51}[§52.11]{PostgreSQLdocc52}[§28.3.34]{Mysqldoc1}{MicrosoftLearnSQLserverInd}

    Индексы важны в плане повышения производительности запросов. Они позволяют ускорить поиск данных, но увеличевают объем занимаемого дискового пространства.

    В словаре данных хранятся метаданные о индексах:
    \begin{itemize}
        \item Название индекса
        \item Тип индекса (\texttt{B-Tree}, \texttt{Hash}, \texttt{GIN}, \texttt{Full-text})
        \item Таблица, к которой индекс относиться
        \item Столбцы, использованные для индексации
        \item Параметры индекса (уникальность, сортировка, частичность)
        \item Статистика использования индекса (сколько раз использовался, степень фрагментации)
    \end{itemize}

    Примеры росположения индексов в разных СУБД:
    \begin{itemize}
        \item PostgreSQL: \texttt{pg\_index}, \texttt{pg\_class}, \texttt{pg\_indexes}
        \item MySQL: \texttt{INFORMATION\_SCHEMA.STATISTICS}
        \item SQL Server: \texttt{sys.indexes}, \texttt{sys.index\_columns}
        \item Oracle: \texttt{DBA\_INDEXES}, \texttt{USER\_INDEXES}
    \end{itemize}

    Пример SQL-запроса (Oracle, получение информации об индексах таблицы):
    \begin{lstlisting}[language=SQL]
    SELECT INDEX_NAME, TABLE_NAME, UNIQUENESS, STATUS 
    FROM DBA_INDEXES 
    WHERE TABLE_NAME = 'EMPLOYEES';
    \end{lstlisting}

    \item Ограничения целостности \autocites[§51.13]{PostgreSQLdocc51}[§28.3.42]{Mysqldoc1}{MicrosoftLearnSQLserverTab}

    Они служат для обиспечения корректности данных в таблицах

    Хранимая информация:
    \begin{itemize}
        \item Тип ограничения (\texttt{PRIMARY KEY} (опреденяет основной ключ таблицы), \texttt{FOREIGN KEY} (обиспечивает ссылочную целостность), \texttt{CHECK} (накл. ограничения на знач. столбцов), \texttt{UNIQUE} (гарантироет уникальность значений в таблице), \texttt{NOT NULL} (запрет хранить NULL в столбце))
        \item Целевая таблица (на которую наклыдвается ограничение целостности) и столбцы
        \item Дейстия при удалении илии обновлении (\texttt{ON DELETE CASCADE}, \texttt{ON UPDATE SET NULL})
    \end{itemize}

    Примеры разположения метаданных об ограничениях в разных СУБД:
    \begin{itemize}
        \item PostgreSQL: \texttt{pg\_constraint}
        \item MySQL: \texttt{INFORMATION\_SCHEMA.KEY\_COLUMN\_USAGE}, \texttt{INFORMATION\_SCHEMA.TABLE\_CONSTRAINTS}
        \item SQLServer: \texttt{sys.foreign\_keys}, \texttt{sys.check\_constraints}, \texttt{sys.key\_constraints}
        \item Oracle: \texttt{ALL\_CONSTRAINTS}, \texttt{USER\_CONSTRAINTS}, \texttt{DBA\_CONSTRAINTS}
    \end{itemize}

    Пример SQL-запроса (PostgreSQL, получение ограничений таблицы):
    \begin{lstlisting}[language=SQL]
    SELECT conname, contype, conrelid::regclass AS table_name 
    FROM pg_constraint 
    WHERE conrelid = 'employees'::regclass; 
    \end{lstlisting}

    Пример SQL-запроса (MySQL, ограничение \texttt{UNIQUE} на \texttt{email} в таблице \texttt{users}):
    \begin{lstlisting}[language=SQL]
    ALTER TABLE users
    ADD CONSTRAINT unique_email UNIQUE (email);    
    \end{lstlisting}

    Пример SQL-запроса (PostgreSQL, ограничение \texttt{FOREIGN KEY} для \texttt{orders.customer\_id}, ссылающееся на \texttt{customers.id}):
    \begin{lstlisting}[language=SQL]
    ALTER TABLE orders
    ADD CONSTRAINT fk_customer FOREIGN KEY (customer_id)
    REFERENCES customers(id) ON DELETE CASCADE;
    \end{lstlisting}

    \item Пользователи и их правами \autocite{MicrosoftLearnSQLserverPerm, oracledbdoc3}

    Для управления доступов к БД в словарке данных хранится информация о прльзователях и их привилегиях и ролях:
    \begin{itemize}
        \item Список всех пользователей СУБД (\texttt{user\_name} пользователей)
        \item Назначенные роли (\texttt{DBA}, \texttt{PUBLIC}, \texttt{SUPERUSER})
        \item Гранты привилегий на обьекты (\texttt{SELECT}, \texttt{INSERT}, \texttt{UPDATE}, \texttt{DELETE})
    \end{itemize}

    Примеры расположения метаданные о пользоватеях в разных СУБД:

    \begin{itemize}
        \item PostgreSQL: \texttt{pg\_roles}, \texttt{pg\_authid}
        \item MySQL: \texttt{mysql.user}, \texttt{INFORMATION\_SCHEMA.USER\_PRIVILEGES}
        \item SQLServer: \texttt{sys.database\_principals}, \texttt{sys.database\_role\_members}
        \item Oracle: \texttt{DBA\_USERS}, \texttt{ALL\_USERS}, \texttt{USER\_USERS}
    \end{itemize}

    Пример SQL-запроса (PostgreSQL):
    \begin{lstlisting}[language=SQL]
    SELECT rolname, rolsuper, rolcreatedb, rolcanlogin 
    FROM pg_roles;             
    \end{lstlisting}

    Пример SQL-запроса (SQL Server, получение списка пользователей и их ролей):
    \begin{lstlisting}[language=SQL]
    SELECT name, type_desc 
    FROM sys.database_principals 
    WHERE type IN ('S', 'U');              
    \end{lstlisting}

\end{enumerate}

\paragraph{Метаданные о транзакциях} ~\\

\begin{grayquote}
    \textbf{Транзакция} - это исполняемая программа, включающая в себя определенные операции с базой данных, такие как чтение из базы данных, применение вставок, удалений или обновлений к базе данных \autocite{ElmasriNavathe}
\end{grayquote}

Основной смысл транзакций заключается в в объединении нескольких операций в одно неделимое действие. Промежуточные состояния между шагами транзакции невидимы для других параллельно выполняющихся транзакций. Если происходит сбой, не позволяющий транзакции завершиться, то никакие изменения базу данных не затрагивают — все шаги откатываются. \autocite{PostgreSQLdocc3p4}

Соответственно, \textbf{метаданные о транзакциях} — это информация, фиксируемая СУБД в процессе выполнения транзакций. Они позволюят отслеживать историю изменений, анализтровать работу БД и обеспечивать контроль целостности данных. В словаре данных хранятся в виде специальных системных таблиц и представлений, которые содержат информацию о выполняемых операциях, механизах блокировок, истории SQL-запросов.

\subparagraph{Журнылы операций} ~\\

\textbf{Журналы операций} фиксируют информацию о транзацкиях выполняемых в СУБЬД чтобы их можно было было восстановить в случае сбоя (сделать \texttt{ROLLBACK}). Они являются основным источником информации о транзакциях в СУБД. Они фиксируют:
\begin{itemize}
    \item Время начала и завершения транзакции
    \item ID транзакции
    \item Тип выполняемой операции (INSERT, UPDATE, DELETE, DDL-операции)
    \item Пользователя, выполнявшего операцию
    \item Затронутые (повергнувшиеся изменению) таблицы и строки
    \item Использованные механизмы блокировок
\end{itemize}

Юзаются они как уже было сказано для отката изменений (\texttt{ROLLBACK}).
Вот как это реализовано в различных СУБД:

\begin{itemize}
    \item PostgreSQL: Журналы транзаций хранятся в WAL (Write-Ahead Logging), а информация о транзакциях пишется в \texttt{pg\_xact} и \texttt{pg\_commit\_ts} \autocite{PostgreSQLdocc28}.
    \item MySQL использует бинарные логи (Binary Log, binlog), который фиксирует события для репликации и востановления. \autocite{Mysqldoc3}. Также есть штука \texttt{performance\_schema.events\_transactions}, которая фиксирует события связанные с выполнением транзакций и хранящяя подробную инфу о них (ID, состояния, временные метки начала и конца, статистику) \autocite{Mysqldoc2}. То есть binlog фиксирует изменения данных для цели репликации, восстановления, а эта штука используется для мониторинга работы транзакций в реальном времени, но не предназначена для восстановления данных. 
    \item SQL Server: журнал транзакций (Transaction Log), \texttt{sys.dm\_tran\_active\_transactions} \autocite{MicrosoftLearnSQLserverTransLog}.
    \item Oracle: журналы восстановления (Redo Logs), \texttt{V\textdollar TRANSACTION}, \texttt{V\textdollar LOG} \autocite{OracleRedoLog}.
\end{itemize}

Пример запроса (PostgreSQL, просмотр текущего состояния WAL-журнала. Как итог получаем текущий LSN (Log Sequence Number) в WAL-журнале. LSN указывает до какого момента были записаны изменения в ужрнале транзакций):
\begin{lstlisting}[language=SQL]
    SELECT * FROM pg_current_wal_lsn();                
\end{lstlisting}

Пример запроса (MySQL, простотр 10 последних записанных в журнал транзакций событий записанных в бинлог):
\begin{lstlisting}[language=SQL]
    SHOW BINLOG EVENTS IN 'mysql-bin.000001' LIMIT 10;           
\end{lstlisting}

\subparagraph{История выполнения SQL-запросов} ~\\

Также многие СУБД ведут \textbf{историю выполненных SQL-запросов}. Она используется для анализа работы системы, поиска узких мест в производительности, аудит безопасности. 

Реализация следующяя:
\begin{itemize}
    \item PostgreSQL: история запросов хранится в \texttt{pg\_stat\_statements} \autocite{PgStatStatements1}
    \item MySQL: используются \texttt{general\_log} и \texttt{slow\_query\_log} \autocite{Mysqldoc3}
    \item SQL Server: представление \texttt{sys.dm\_exec\_query\_stats} \autocite{MicrosoftLearnSQLserverQueryStat}
    \item Oracle: динамические представления \texttt{V\textdollar SQL}, \texttt{V\textdollar SQLAREA} \autocite[c.9 §46-49, c.9 §71]{oracledbdoc2}
\end{itemize}

Пример запроса (PostgreSQL, выводит 5 самых долгих рисурсоемких запросов):
\begin{lstlisting}[language=SQL]
    SELECT query, calls, total_exec_time 
    FROM pg_stat_statements 
    ORDER BY total_exec_time DESC 
    LIMIT 5;                 
\end{lstlisting}

Пример запроса (Oracle, \texttt{V\textdollar SQLAREA}, выборка последних запросов с частотой их выполнения и затратами ресурсов (10 штук запросов)):
\begin{lstlisting}[language=SQL]
    SELECT sql_text, executions, 
        elapsed_time / executions AS avg_exec_time, 
        disk_reads, buffer_gets 
    FROM V$SQLAREA 
    WHERE executions > 0 
    ORDER BY first_load_time DESC 
    FETCH FIRST 10 ROWS ONLY;
\end{lstlisting}

\subparagraph{Информация о блокировакх и параллельном доступе} ~\\

Монгопользоательский доступ требуеи механизмов блркировок для отсутствия ситуации когда происходит одновременная модификация одних и техже данных разными транзакциями. В словаре данных фиксируется информация о:
\begin{itemize}
    \item Активных блокировках (\texttt{SHARE}, \texttt{EXCLUSIVE})
    \item Процессах, ожидающих снятия блокировок
    \item Возникших взаимоблокировках (deadlocks)
    \item Длительности удержания блокировки
    \item Таблицах и строках, находящихся в блокировке
\end{itemize}

На практике реализоввано следующим образом:
\begin{itemize}
    \item PostgreSQL: Информация о блокировках содержится в \texttt{pg\_locks} и \texttt{pg\_stat\_activity} \autocites[§52.12]{PostgreSQLdocc52}[§27.2.3]{PostgreSQLdocc27}
    \item MySQL: \texttt{performance\_schema.metadata\_locks} \autocite[§29.12.13]{Mysqldoc2}
    \item SQL Server: используется представление \texttt{sys.dm\_tran\_locks} \autocite{MicrosoftLearnSQLserverTranLocks}
    \item Oracle: блокировки отслеживаются \texttt{V\textdollar LOCK}, \texttt{DBA\_BLOCKERS}, \texttt{DBA\_WAITERS} \autocites[c.8 §40]{oracledbdoc2}[c.4 §180, c.6 §103]{oracledbdoc1}
\end{itemize}

Пример запроса (PostgreSQL, поиск процессов ожидающих блокировки):
\begin{lstlisting}[language=SQL]
    SELECT pid, relation::regclass AS locked_table, mode, granted
    FROM pg_locks
    WHERE NOT granted;              
\end{lstlisting}

Пример запроса (SQL Server, поиск взаимоблокировок):
\begin{lstlisting}[language=SQL]
    SELECT blocking_session_id AS blocker, session_id AS blocked
    FROM sys.dm_exec_requests
    WHERE blocking_session_id IS NOT NULL;             
\end{lstlisting}

Согласно требованиям ACID (Atomic, Consistent, Isolated, Durable) транзакция должна быть устойчивой. После своего завершения она сохраняется в системе, которую ничто не может вернуть в исходное (до начала транзакции) состояние, т. е. происходит фиксация транзакции (\texttt{COMMIT}), означающая, что ее действие постоянно даже при сбое системы. При выполнении отдельных операций транзакции могут быть нарушены какие-либо требования целостности данных (в первую очередь имеются в виду корпоративные правила целостности, см. главу 2). Однако по окончании выполнения транзакции (фиксация транзакции) все правила целостности базы данных будут соблюдены.

В большинстве реляционных СУБД фиксация сначала записывает изменения в журнал транзакций (например, WAL или Binary Log), а затем применяет их к основным данным. Это позволяет минимизировать потери в случае сбоя и поддерживать \texttt{ROLLBACK}, если транзакция не была завершена.

Транзакция начинается с первой команды, которая обращается к данным, и продолжается до тех пор, пока не будет явного завершения с помощью \texttt{COMMIT WORK} (или просто \texttt{COMMIT}) либо не будет закрыто соединение к базе данных. Ткаже возможно явное открытие транзакии с помощью \texttt{BEGIN TRANSACTION} (\texttt{START TRANSACTION} в MySQL). При выполнении \texttt{COMMIT} происходит фиксация транзакции, и \texttt{ROLLBACK} уже будет невозможен \autocite{Pirogov2009}. Однако поведение на самом деле зависит от СУБД.

Например, в PostgreSQL и MySQL разрыв соединения без \texttt{COMMIT} приводит к автоматическому \texttt{ROLLBACK}, а в SQL Server и Oracle возможны различные настройки (по умолчанию транзакция фиксируется при разрыве соединение но можно включить поведение с откатом).

Пример явного управления транзакцией в PostgreSQL (демонстрация атомарности транзакции при переводе средств между мнимымии счетами):
\begin{lstlisting}[language=SQL]
    BEGIN;
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;
    COMMIT;           
\end{lstlisting}


\paragraph{Статистика работы СУБД} ~\\

Статистика работы СУБД также представляет из себя метаданные которые фиксируют информацию о произчодительности системы, нагрузке на сервер, использовании индексов, частоте выполнения запросов. Подобного рода данные дают возможность админам анализировать производительность БД и оптимизировать систему.

\subparagraph{Анализ производительности} ~\\

Анализ производительности позволяет определить, какие запросы и операции замедляют работу СУБД. Для этого мониторится:
\begin{itemize}
    \item Использование процессора (время выполнения SQL-запросов, нагрузка на CPU)
    \item Операции чтения/записи на диск и использование кэша
    \item Потребление памяти (размер буферного кэша, использование индексов)
\end{itemize}

В разных СУБД следующие механизмы для анализа производительности:
\begin{itemize}
    \item PostgreSQL: \texttt{pg\_stat\_statements}, \texttt{pg\_stat\_activity}, \texttt{pg\_stat\_bgwriter} \autocite[§27.2]{PostgreSQLdocc27}
    \item MySQL: \texttt{performance\_schema}, \texttt{INFORMATION\_SCHEMA.PROCESSLIST} \autocite{Mysqldoc2}
    \item SQL Server: \texttt{sys.dm\_exec\_requests}, \texttt{sys.dm\_exec\_query\_stats} \autocite{MicrosoftLearnSQLserverSysDymView}
    \item Oracle: \texttt{V\textdollar SYSSTAT}, \texttt{V\textdollar SESSION}, \texttt{V\textdollar SQL} \autocite[c. 9 §9.98, §9.17, §9.46]{oracledbdoc2}
\end{itemize}

Пример PostgreSQL — анализ нагрузки активных запросов. Опридиляет SQL-запросы с наибольшим временем выполнения:
\begin{lstlisting}[language=SQL]
    SELECT pid, query, calls, total_exec_time / calls AS avg_exec_time
    FROM pg_stat_statements
    ORDER BY avg_exec_time DESC
    LIMIT 5;        
\end{lstlisting}

Другой пример (MySQL, анализ медленных запросов)
\begin{lstlisting}[language=SQL]
    SELECT start_time, user_host, query_time, sql_text
    FROM mysql.slow_log
    ORDER BY query_time DESC
    LIMIT 5;        
\end{lstlisting}

\subparagraph{Статистика выполнения запросов} ~\\

Статистические данные также использутся для оптимизации индексов (анализируется частота обращения к различным таблицам), выявления "дорогих" запросов (запросов с высокой нагрузкой на процессор или диск) и настройки кэша и оценки эффективности буферизации данных.

Примеры механизмов сбора статистики запросов:
\begin{itemize}
    \item PostgreSQL: \texttt{pg\_stat\_statements} хранит частоту и среднее время выполнения запросов
    \item MySQL: \texttt{performance\_schema.events\_statements\_summary\_by\_digest} агрегирует запросы по шаблону
    \item SQL Server: \texttt{sys.dm\_exec\_query\_stats} дает инфорамцию о частоте выполнения запросов
    \item Oracle: \texttt{V\textdollar SQLAREA} хранить статистику о выполненных запросах
\end{itemize}

Пример (SQL Server, анализ самых ресурсозатратных запросов)
\begin{lstlisting}[language=SQL]
    SELECT TOP 5 
        total_logical_reads AS Reads, 
        total_worker_time AS CPU_Time, 
        execution_count AS Executions, 
        text AS Query_Text 
    FROM sys.dm_exec_query_stats qs
    CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle)
    ORDER BY total_worker_time DESC;
\end{lstlisting}

Пример (Oracle, последние 10 выполненных запросов, показывает частоту и среднее время выполнения)
\begin{lstlisting}[language=SQL]
    SELECT sql_text, executions, elapsed_time / executions AS avg_exec_time
    FROM V$SQLAREA
    WHERE executions > 0
    ORDER BY first_load_time DESC
    FETCH FIRST 10 ROWS ONLY;
\end{lstlisting}

\subparagraph{Автоматическая сборка аналитики СУБД} ~\\

Некоторые (все из рассматриваемых четырех) СУБД автоматически автоматически анализируют статистику и используют её для внутренней оптимизации
\begin{itemize}
    \item PostgreSQL: \texttt{pg\_stat\_statements} автоматически анализирует запросы и создает план выполнения
    \item MySQL: \texttt{performance\_schema.setup\_instruments} мониторит работу серверных процессов
    \item SQL Server: \texttt{Query Store} хранит статистку выполнения запросов и их планы
    \item Oracle: \texttt{V\textdollar SQL\_PLAN}, \texttt{V\textdollar SQL\_OPTIMIZER\_ENV} отслеживают параметры оптимизатора
\end{itemize}

Пример (PostgreSQL, анализ частоты выполнения запросов)
\begin{lstlisting}[language=SQL]
    SELECT query, calls, total_exec_time / calls AS avg_exec_time
    FROM pg_stat_statements
    ORDER BY calls DESC
    LIMIT 10;
\end{lstlisting}

Пример (Oracle, анализ плана выполнения запроса)
\begin{lstlisting}[language=SQL]
    SELECT sql_id, plan_hash_value, executions, buffer_gets, elapsed_time
    FROM V$SQL_PLAN
    ORDER BY elapsed_time DESC
    FETCH FIRST 5 ROWS ONLY;
\end{lstlisting}






\paragraph{Типы словарей данных} ~\\

Существует два типа словарей данных. Активные и пассивные, они отличаются уровнем автоматической синхронизации \autocite{DataDictionary}:

\begin{grayquote}
    \textbf{Активные словари данных} -- словари данных, созданные в описываемых ими базах данных, которые автоматически отражают любые изменения внутри этих баз, что позволяет избежать любых несоответствий между словарями данных и описываемыми данными.
\end{grayquote}

\begin{grayquote}
    \textbf{Словари пассивных данных} -- словари данных, созданные как отдельные от описываемых ими баз данных сущности. Они требуют дополнительной логики для синхронизации с базами данных, которые они описывают.
\end{grayquote}

\paragraph{Доступ к словарю данных} ~\\

По 4 правилу Кодда (Dynamic On-Line Catalog Based on the Relational Model) словарь данных должен сохраняться в форме реляционных таблиц, и СУБД должна поддерживать доступ к нему при помощи стандартных языковых средств.


Для доступа к словарю данных используются инструкции SQL. Так как словарь данных доступен только для чтения, допускается выполнять только запросы таблиц и представлений.

Можно запрашивать представления словаря, которые основаны на таблицах словаря, чтобы найти сведения, такие как \autocite{SqlOracle}:
\begin{itemize}
    \item Определения всех объектов схемы в словаре (таблицы, представления, индексы, синонимы, последовательности, процедуры, функции, пакеты, триггеры и так далее);
    \item Значения по умолчанию для столбцов;
    \item Сведения об ограничениях целостности;
    \item Имена пользователей Oracle;
    \item Привилегии и роли, предоставленные каждому пользователю;
    \item Другие общие сведения о базе данных.
\end{itemize}


\paragraph{Прокрутки вперед и назад} ~\\

В результате сбоя СУБД могут возникнуть две потенциальные ситуации \autocite{Karpova2009}:

\begin{itemize}
    \item Блоки, содержащие подтверждённые модификации, не были записаны в файлы данных, так что эти изменения отражены лишь в журнале транзакций. Следовательно, журнал транзакций содержит подтверждённые данные, которые должны быть переписаны в файлы данных.
    \item Журнал транзакций и блоки данных содержат изменения, которые не были подтверждены. Изменения, внесенные неподтверждёнными транзакциями, во время восстановления БД должны быть удалены из файлов данных.
\end{itemize}

Для того чтобы разрешить эти ситуации, СУБД автоматически выполняет два этапа при восстановлении после сбоев: прокрутку вперед и прокрутку назад.

\begin{enumerate}
    \item Прокрутка вперед заключается в применении к файлам данных всех изменений, зарегистрированных в журнале транзакций. После прокрутки вперед файлы данных содержат все как подтверждённые, так и неподтверждённые изменения, которые были зарегистрированы в журнале транзакций.
    \item Прокрутка назад заключается в отмене всех изменений, которые не были подтверждены. Для этого используются журнал транзакций и сегменты отката, информация из которых позволяет определить и отменить те транзакции, которые не были подтверждены, хотя и попали на диск в файлы БД.
\end{enumerate}

После выполнения этих этапов восстановления БД находится в согласованном состоянии и с ней можно работать.

\paragraph{Контрольная точка} ~\\

Критическим моментом в отказе системы является потеря содержимого основной (оперативной) памяти (в частности, буферов базы данных). Поскольку точное состояние любой выполнявшейся в момент отказа системы транзакции остается неизвестным, такая транзакция не может быть успешно завершена. Поэтому при перезапуске системы любая такая транзакция будет отменена (т.е. будет выполнен ее откат). 


Более того, при перезапуске системы, возможно, потребуется повторно выполнить некоторые транзакции, которые были успешно завершены до аварийного останова, но выполненные ими обновления еще не были перенесены из буферов оперативной памяти в физическую базу данных во вторичной памяти.


Возникает очевидный вопрос: как система определяет в процессе перезапуска, какую транзакцию следует отменить, а какую выполнить повторно? Ответ заключается в том, что система автоматически создает контрольные точки с некоторым наперед заданным интервалом (обычно, когда в журнале накапливается определенное число записей). Для создания контрольной точки требуется \autocite{Date2005}:

\begin{enumerate}
    \item Выполнить принудительное сохранение содержимого буферов оперативной памяти в физической базе данных 
    \item Осуществить принудительное сохранение специальной записи контрольной точки в журнале на физическом носителе. Запись контрольной точки содержит список всех транзакций, выполняемых в тот момент, когда создавалась контрольная точка.
\end{enumerate}

\paragraph{Откат} ~\\

Для управления транзакциями в системах, поддерживающих механизм транзакций и язык SQL, используется оператор отката транзакции (отмены изменений): ROLLBACK [WORK]. Для фиксации или отката транзакции система создаёт неявные точки фиксации и отката. По команде rollback система откатит транзакцию на начало (на неявную точку отката).

Для обеспечения целостности транзакции СУБД может откладывать запись изменений в БД до момента успешного выполнения всех операций, входящих в транзакцию, и получения команды подтверждения транзакции (commit). Но чаще используется другой подход: система записывает изменения в БД, не дожидаясь завершения транзакции, а старые значения данных сохраняет на время выполнения транзакции в сегментах отката.

\textbf{Сегмент отката (Rollback Segment, RBS)} – это специальная область памяти на диске, в которую записывается информация обо всех текущих (незавершённых) изменениях. Обычно записывается "старое" и "новое" содержимое изменённых записей, чтобы можно было восстановить прежнее состояние БД при откате транзакции (по команде rollback) или при откате текущей операции (в случае возникновения ошибки). Данные в RBS хранятся до тех пор, пока транзакция, изменяющая эти данные, не будет завершена. Потом они могут быть перезаписаны данными более поздних транзакций.


Команда savepoint запоминает промежуточную "текущую копию" состояния базы данных для того, чтобы при необходимости можно было вернуться к состоянию БД в точке сохранения: откатить работу от текущего момента до точки сохранения (rollback to <имя\_точки>) или зафиксировать работу от начала транзакции до точки сохранения (commit to <имя\_точки>). На одну транзакцию может быть несколько точек сохранения (ограничение на их количество зависит от СУБД). Для сохранения сведений о транзакциях СУБД ведёт журнал транзакций. 

\textbf{Журнал транзакций} –- это часть БД, в которую поступают данные обо всех изменениях всех объектов БД. Журнал недоступен пользователям СУБД и поддерживается особо тщательно (иногда ведутся две копии журнала, хранимые на разных физических носителях). 

Форма записи в журнал изменений зависит от СУБД. Но обычно там фиксируется следующее:

\begin{itemize}
    \item Номер транзакции (номера присваиваются автоматически по возрастанию);
    \item Состояние транзакции (завершена фиксацией или откатом, не завершена, находится в состоянии ожидания);
    \item Точки сохранения (явные и неявные);
    \item Команды, составляющие транзакцию, и прочие
\end{itemize}

Начало транзакции соответствует появлению первого исполняемого SQLоператора. При этом в журнале появляется запись об этой транзакции \autocite{Karpova2009}.

\paragraph{Транзакции как средство изолированности пользователей} ~\\

Поддержание механизма транзакций —- показатель уровня развитости СУБД и основа обеспечения целостности базы данных. Транзакции также составляют основу изолированности в многопользовательских системах, где с одной базой данных параллельно могут работать несколько пользователей и (или) прикладных программ. 


Одна из основных задач СУБД —- обеспечение изолированности, т. е. создание такого режима функционирования, при котором каждому пользователю казалось бы, что база данных доступна только ему. Такую задачу СУБД принято называть параллелизмом транзакций. Большинство выполняемых действий производится в теле транзакций. По умолчанию каждая команда выполняется как самостоятельная транзакция. Как было показано ранее, при необходимости пользователь может явно указать ее начало и конец, чтобы иметь возможность включить в нее несколько команд.


Решение проблемы параллельной обработки базы данных заключается в том, что строки таблиц блокируются, а последующие транзакции, модифицирующие эти строки, отвергаются и переводятся в режим ожидания. В связи со свойством сохранения целостности базы данных транзакции являются подходящими единицами изолированности пользователей. Действительно, если каждый сеанс взаимодействия с базой данных реализуется транзакцией, то пользователь начинает с того, что обращается к согласованному состоянию базы данных — состоянию, в котором она могла бы находиться, даже если бы пользователь работал с ней в одиночку.


Если бы в СУБД не были реализованы механизмы блокирования, то при одновременном чтении и изменении одних и тех же данных несколькими пользователями могли бы возникнуть проблемы одновременного доступа.


\paragraph{Конфликты транзакций и уровни изоляции} ~\\

Уровни изоляции определяют степень, в которой транзакция должна быть изолирована от изменений данных, сделанных любой другой транзакцией в системе базы данных. Уровни изоляции отличаются разрешениями следующих конфликтов:

\begin{itemize}
    \item 
        \textbf{Потерянное обновление (Lost Update)} — когда несколько транзакций что-то обновили в БД, но по итогам результат такой, будто отработала лишь часть транзакций. Самый опасный побочный эффект, по сути, полное отсутствие изоляции транзакций — две транзакции читают одну ячейку, записывают изменённое значение (одна вычитает стоимость мороженого, другая плату за квартиру). В итоге в ячейке значение от второй транзакции, а первой как будто и не было.
    \item 
        \textbf{Грязное чтение (Dirty Read)} — ситуация, когда транзакция считывает данные, которые еще не были зафиксированы. Например, транзакция 1 обновляет строку и оставляет ее незафиксированной, в то время как транзакция 2 читает обновленную строку. Если транзакция 1 откатывает изменение, транзакция 2 будет считывать данные, которые считаются никогда не существовавшими.
    \item 
        \textbf{Неповторяемое чтение (Non-repeatable Read)} — когда транзакция дважды считывает одну и ту же строку и каждый раз получает другое значение. Например, предположим, что транзакция T1 считывает данные. Из-за параллелизма другая транзакция T2 обновляет те же данные и фиксирует их. Теперь, если транзакция T1 повторно считывает те же данные, она получит другое значение.
    \item 
        \textbf{Фантомное чтение (Phantom Reads)} — когда выполняются два одинаковых запроса, но извлекаемые ими строки различаются. Например, транзакция T1 извлекает набор строк, удовлетворяющих некоторым критериям поиска. Далее транзакция T2 создает несколько новых строк, соответствующих критериям поиска для транзакции T1. Если транзакция T1 повторно выполняет инструкцию, которая считывает строки, на этот раз она получает другой набор строк. Отличие от предыдущего пункта в том, что в этом случае происходит агрегация строк, а в предыдущем происходит чтение лишь одной строки.
\end{itemize}

Основываясь на политиках разрешения перечисленных конфликтов, стандарт SQL определяет четыре уровня изоляции:

\begin{itemize}
    \item 
        \textbf{Read Uncommitted} — это самый низкий уровень изоляции. На этом уровне одна транзакция может считывать еще не зафиксированные изменения, сделанные другими транзакциями, тем самым допуская грязное чтение. На этом уровне транзакции не изолированы друг от друга.
    \item 
        \textbf{Read Committed} — уровень изоляции гарантирует, что любые считанные данные фиксируются в момент их чтения. Таким образом, он не допускает грязного чтения. Транзакция удерживает блокировку чтения или записи для текущей строки и, таким образом, предотвращает ее чтение, обновление или удаление другими транзакциями.
    \item 
        \textbf{Repeatable Read} — транзакция удерживает блокировки чтения для всех строк, на которые она ссылается, и записывает блокировки для указанных строк для действий обновления и удаления. Поскольку другие транзакции не могут читать, обновлять или удалять эти строки, следовательно, это позволяет избежать неповторяющегося чтения.
    \item 
        \textbf{Serializable} — самый высокий уровень изоляции. Выполнение определяется как выполнение операций, в которых одновременно выполняемые транзакции кажутся последовательно выполняемыми \autocite{BeginningSQL}.
\end{itemize}

\begin{table}[h]
\begin{tabularx}{\textwidth}{|X|X|X|X|X|}
    \hline
                     & Фантомное чтение         & Неповторяющееся чтение   & Грязное чтение           & Потерянное обновление    \\ \hline
    Serializable     & \cellcolor[HTML]{32CB00} & \cellcolor[HTML]{32CB00} & \cellcolor[HTML]{32CB00} & \cellcolor[HTML]{32CB00} \\ \hline
    Repeatable Read  & \cellcolor[HTML]{FE0000} & \cellcolor[HTML]{32CB00} & \cellcolor[HTML]{32CB00} & \cellcolor[HTML]{32CB00} \\ \hline
    Read Committed   & \cellcolor[HTML]{FE0000} & \cellcolor[HTML]{FE0000} & \cellcolor[HTML]{32CB00} & \cellcolor[HTML]{32CB00} \\ \hline
    Read Uncommitted & \cellcolor[HTML]{FE0000} & \cellcolor[HTML]{FE0000} & \cellcolor[HTML]{FE0000} & \cellcolor[HTML]{32CB00} \\ \hline
\end{tabularx}
\caption{Уровни изоляции транзакций}
\end{table}


\paragraph{Методы сериализации транзакций} ~\\

Делятся на три типа:

\begin{itemize}
    \item 
        \textbf{С блокирующим планировщиком (Blocking Sheduler)} — для каждого запроса планировщик запрашивает блокировку. Каждая блокировка запрашивается в определенном режиме (чтение или запись). Если запрашиваемый элемент данных еще не заблокирован в несовместимом режиме, блокировка предоставляется; в противном случае возникает конфликт блокировок и транзакция блокируется, пока текущий владелец блокировки не освободит блокировку. Например: двухфазные AL (Altruistic Locking), O2PL (Ordered Sharing of Locks), 2PL (Two-Phase Locking), C2PL (Conservative Two-Phase Locking), S2PL (Strict Two-Phase Locking), SS2PL (Strong Strict Two-Phase Locking), не двухфазные WTL (Write-only Tree Locking), RWTL (Read-Write Tree Locking).
    \item 
        \textbf{С неблокирующим планировщиком (Non-Blocking Sheduler)} — запрос отрабатывает, не имея возможности заблокировать другой запрос, конфликты разрешаются постфактум. Например: TO (Timestamp Ordering), SGT (Serialization Graph Testing).
    \item 
        \textbf{Смешанный} — использует разные типы для разных видов конфликтов (rw/wr, ww).\autocite{TransactionalInformationSystems}
\end{itemize}

\subsection{Блокировки} ~\\

Блокировки, называемые также синхронизационными захватами объектов, могут быть применены к разному типу объектов. Наибольшим объектом блокировки может быть вся БД, однако этот вид блокировки сделает БД недоступной для всех приложений, которые работают с данной БД. Следующий тип объекта блокировки —- это таблицы. Транзакция, которая работает с таблицей, блокирует ее на все время выполнения транзакции. Этот вид блокировки предпочтительнее предыдущего, потому что позволяет параллельно выполнять транзакции, которые работают с другими таблицами.


В ряде СУБД реализована блокировка на уровне страниц. В этом случае СУБД блокирует только отдельные страницы на диске, когда транзакция обращается к ним. Этот вид блокировки еще более мягок и позволяет разным транзакциям работать даже с одной и той же таблицей, если они обращаются к разным страницам данных.


В некоторых СУБД возможна блокировка на уровне строк, однако такой механизм блокировки требует дополнительных затрат на поддержку этого вида блокировки. В настоящее время проблема блокировок является предметом большого числа исследований \autocite{Intuit}.

\paragraph{Режимы блокировок} ~\\

Рассматривают два типа блокировок (синхронизационных захватов) \autocite{Intuit}:

\begin{itemize}
    \item 
        \textbf{Совместный режим блокировки} — нежесткая, или разделяемая, блокировка, обозначаемая как S (Shared). Этот режим обозначает разделяемый захват объекта и требуется для выполнения операции чтения объекта. Объекты, заблокированные таким образом, не изменяются в ходе выполнения транзакции и доступны другим транзакциям также, но только в режиме чтения;
    \item 
        \textbf{Монопольный режим блокировки} — жесткая, или эксклюзивная, блокировка, обозначаемая как X (eXclusive). Данный режим блокировки предполагает монопольный захват объекта и требуется для выполнения операций занесения, удаления и модификации. Объекты, заблокированные данным типом блокировки, фактически остаются в монопольном режиме обработки и недоступны для других транзакций до момента окончания работы данной транзакции.
\end{itemize}

\paragraph{Правила согласования блокировок}~\\

Захваты объектов несколькими транзакциями по чтению совместимы, то есть нескольким транзакциям допускается читать один и тот же объект, захват объекта одной транзакцией по чтению не совместим с захватом другой транзакцией того же объекта по записи, и захваты одного объекта разными транзакциями по записи не совместимы. В примере, представленном на рис. 1 считается, что первой блокирует объект транзакция А, а потом пытается получить к нему доступ транзакция В.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{assets/blocks.PNG}
    \caption{Правила применения жесткой и нежесткой блокировок транзакций}
\end{figure}


\paragraph{Двухфазный протокол синхронизационных блокировок}~\\

В базах данных и обработке транзакций двухфазная блокировка (2PL) — это метод управления параллелизмом, который гарантирует сериализуемость. Так же называют результирующий набор графиков транзакций базы данных (истории). Протокол использует блокировки, применяемые транзакцией к данным, которые могут блокировать (интерпретировать как сигналы для остановки) другие транзакции от доступа к тем же данным в течение жизни транзакции.


По протоколу 2PL блокировки (locks) применяются и удаляются в два этапа:

\begin{enumerate}
    \item Фаза расширения: блокировки берутся и ни одна блокировка не освобождается.
    \item Фаза сокращения: блокировки освобождаются и ни одна блокировка не берётся.
\end{enumerate}

В базовом протоколе используются два типа блокировок: Shared и Exclusive locks. Уточнения базового протокола могут использовать больше типов блокировок. Используя блокировки, блокирующие процессы, 2PL могут подвергаться взаимоблокировкам, которые являются результатом взаимной блокировки двух или более транзакций \autocite{Wiki}.

\paragraph{Тупиковые ситуации, их распознавание и разрушение} ~\\

Одним из наиболее чувствительных недостатков метода сериализации транзакций на основе синхронизационных захватов является возможность возникновение тупиков (deadlocks) между транзакциями.

Вот простой пример возникновения тупика между транзакциями T1 и T2:
\begin{enumerate}
    \item Транзакции T1 и T2 установили монопольные захваты объектов r1 и r2 соответственно;
    \item После этого T1 требуется совместный захват r2, а T2 - совместный захват r1;
    \item Ни одна из транзакций не может продолжаться, следовательно, монопольные захваты не будут сняты, а совместные - не будут удовлетворены.
\end{enumerate}

Поскольку тупики возможны, и никакого естественного выхода из тупиковой ситуации не существует, то эти ситуации необходимо обнаруживать и искусственно устранять.

Основой обнаружения тупиковых ситуаций является построение (или постоянное поддержание) графа ожидания транзакций. Граф ожидания транзакций - это ориентированный двудольный граф, в котором существует два типа вершин - вершины, соответствующие транзакциям, и вершины, соответствующие объектам захвата. В этом графе существует дуга, ведущая из вершины-транзакции к вершине-объекту, если для этой транзакции существует удовлетворенный захват объекта. В графе существует дуга из вершины-объекта к вершине-транзакции, если транзакция ожидает удовлетворения захвата объекта.


Легко показать, что в системе существует ситуация тупика, если в графе ожидания транзакций имеется хотя бы один цикл. Для распознавание тупика периодически производится построение графа ожидания транзакций (как уже отмечалось, иногда граф ожидания поддерживается постоянно), и в этом графе ищутся циклы. Традиционной техникой (для которой существует множество разновидностей) нахождения циклов в ориентированном графе является редукция графа.


Не вдаваясь в детали, редукция состоит в том, что прежде всего из графа ожидания удаляются все дуги, исходящие из вершин-транзакций, в которые не входят дуги из вершин-объектов. (Это как бы соответствует той ситуации, что транзакции, не ожидающие удовлетворения захватов, успешно завершились и освободили захваты). Для тех вершин-объектов, для которых не осталось входящих дуг, но существуют исходящие, ориентация исходящих дуг изменяется на противоположную (это моделирует удовлетворение захватов). После этого снова срабатывает первый шаг и так до тех пор, пока на первом шаге не прекратится удаление дуг. Если в графе остались дуги, то они обязательно образуют цикл.


Предположим, что нам удалось найти цикл в графе ожидания транзакций. Что делать теперь? Нужно каким-то образом обеспечить возможность продолжения работы хотя бы для части транзакций, попавших в тупик. Разрушение тупика начинается с выбора в цикле транзакций так называемой транзакции-жертвы, т.е. транзакции, которой решено пожертвовать, чтобы обеспечить возможность продолжения работы других транзакций. Грубо говоря, критерием выбора является стоимость транзакции; жертвой выбирается самая дешевая транзакция. Стоимость транзакции определяется на основе многофакторная оценка, в которую с разными весами входят время выполнения, число накопленных захватов, приоритет. После выбора транзакции-жертвы выполняется откат этой транзакции, который может носить полный или частичный характер. При этом, естественно, освобождаются захваты и может быть продолжено выполнение других транзакций.


Естественно, такое насильственное устранение тупиковых ситуаций является нарушением принципа изолированности пользователей, которого невозможно избежать. Заметим, что в централизованных системах стоимость построения графа ожидания сравнительно невелика, но она становится слишком большой в по-настоящему распределенных СУБД, в которых транзакции могут выполняться в разных узлах сети. Поэтому в таких системах обычно используются другие методы сериализации транзакций.


Еще одно замечание. Чтобы минимизировать число конфликтов между транзакциями, в некоторых СУБД (например, в Oracle) используется следующее развитие подхода. Монопольный захват объекта блокирует только изменяющие транзакции. После выполнении операции модификации предыдущая версия объекта остается доступной для чтения в других транзакциях. Кратковременная блокировка чтения требуется только на период фиксации изменяющей транзакции, когда обновленные объекты становятся текущими \autocite{Serial}

\subsection{Ссылочная целостность}

Ссылочная целостность. Ссылочная целостность относится непосредственно к связям между таблицами. Если кратко, то ссылочная целостность должна отвечать на вопрос: что будет со строками одной таблицы, если в связанной таблице выполняется какая-либо операция модификации? Для того чтобы понять логику ссылочной целостности, будем считать таблицу главной в паре связанных таблиц, если она содержит первичный ключ, с помощью которого осуществляется связь. Вторую таблицу будем считать подчиненной таблицей. Теперь выделим три вида операции над связанными таблицами: удаление из главной таблицы, обновление строк главной таблицы, вставка в подчиненную таблицу.

\begin{enumerate}
    \item Удаление строк из главной таблицы. Если удаляемая строка не связана со строками другой таблицы, то удалять можно без всяких последствий. Но если удаляемая строка связана со строками другой таблицы, то надо подумать, что же будет с этими строками. Просто оставить их без изменения нельзя, т. к. не понятно, как быть со значениями внешних ключей. В принципе, возможны следующие четыре сценария, поддерживаемые основными СУБД:
        \begin{itemize}
            \item строки из подчиненной таблицы должны быть удалены вместе со связанными строками из подчиненной таблицы. Такой механизм называется каскадированием;
            \item если удаляемая строка из главной таблицы связана со сроками из подчиненной таблицы, то такая операция удаления должна быть отвергнута. Данный механизм наиболее безопасен и предпочтителен при построении информационной системы;
            \item если строка в подчиненной таблице связана с удаляемой строкой в главной таблице, то внешнему ключу следует присвоить значение NULL;
            \item если строка в подчиненной таблице связана с удаляемой строкой в главной таблице, то внешнему ключу следует присвоить значение, принятое по умолчанию.
        \end{itemize}
    
    \item Обновление строк из главной таблицы. Если обновляемая строка не связана со строками другой таблицы или обновляются столбцы, не от- носящиеся к первичному ключу, то обновлять можно без всяких последствий. Но если обновляемая строка связана со строками другой таблицы и обновляется первичный ключ, то здесь, как и в предыдущем случае, возможны четыре сценария:
        \begin{itemize}
            \item первичные ключи из главной таблицы обновляются вместе с внешними ключами подчиненной таблицы. Как и в случае с подобной операцией удаления, этот механизм называется каскадированием;
            \item если обновляемая строка связана с какой-либо строкой подчиненной таблицы, то операция обновления должна быть отвергнута;
            \item если строка в подчиненной таблице связана с обновляемой строкой в главной таблице, то внешнему ключу следует присвоить значение NULL;
            \item если строка в подчиненной таблице связана с обновляемой строкой в главной таблице, то внешнему ключу следует присвоить значение, принятое по умолчанию.
        \end{itemize}

    \item Вставка строк в подчиненную таблицу. Здесь возможны следующие механизмы.
        \begin{itemize}
            \item Строка в подчиненной таблице вставляется вместе со строкой в главной таблице. Здесь важно иметь в виду, что в главной таблице для всех столбцов должны быть определены значения по умолчанию. Последовательность добавления такая: вначале добавляется строка в главную таблицу и определяется значение первичного ключа. Затем добавляется строка в подчиненную таблицу, в которой значению внешнего ключа присваивается значение первичного клю- ча в главной таблице.
            \item Строка в подчиненную таблицу добавляется только при условии, что соответствующая ей строка в главной таблице уже существует.
            \item При добавлении строки в подчиненную таблицу внешнему ключу присваивается значение NULL.
            \item При добавлении строки в подчиненную таблицу внешнему ключу присваивается значение по умолчанию.
        \end{itemize}
\end{enumerate}

В некоторых простых СУБД отсутствует возможность устанавливать связи между таблицами и, таким образом, поддерживать ссылочную целостность. В этом случае поддержание ссылочной целостности полностью ложится на плечи программиста. Другими словами, связь между таблицами должна быть реализована на уровне прикладного программного обеспечения.

\paragraph{Декларативная и процедурная ссылочные целостности} ~\\

Различают два способа реализации ограничений целостности:

\begin{itemize}
    \item Декларативная поддержка ограничений целостности.
    \item Процедурная поддержка ограничений целостности.
\end{itemize}

\begin{grayquote}
    \textbf{Декларативная поддержка ограничений целостности} заключается в определении ограничений средствами языка определения данных (DDL - Data Definition Language). Обычно средства декларативной поддержки целостности (если они имеются в СУБД) определяют ограничения на значения доменов и атрибутов, целостность сущностей (потенциальные ключи отношений) и ссылочную целостность (целостность внешних ключей). Декларативные ограничения целостности можно использовать при создании и модификации таблиц средствами языка DDL или в виде отдельных утверждений (ASSERTION).
\end{grayquote}

Например, следующий оператор создает таблицу PERSON и определяет для нее некоторые ограничения целостности:

\begin{verbatim}
CREATE TABLE PERSON
  (Pers_Id INTEGER PRIMARY KEY,
  Pers_Name CHAR(30) NOT NULL,
  Dept_Id REFERENCES DEPART(Dept_Id) ON UPDATE CASCADE ON DELETE CASCADE);
\end{verbatim}

После выполнения оператора для таблицы PERSON будут объявлены следующие ограничения целостности:

\begin{itemize}
    \item Поле Pers\_Id образует потенциальный ключ отношения.
    \item Поле Pers\_Name не может содержать null-значений.
    \item Поле Dept\_Id является внешней ссылкой на родительскую таблицу DEPART, причем, при изменении или удалении строки в родительской таблице каскадно должны быть внесены соответствующие изменения в дочернюю таблицу.
\end{itemize}

\begin{grayquote}
    \textbf{Процедурная поддержка ограничений целостности} заключается в использовании триггеров и хранимых процедур.
\end{grayquote}

Не все ограничения целостности можно реализовать декларативно. Примером такого ограничения может служить требование из примера 1, утверждающее, что поле Dept\_Kol таблицы DEPART должно содержать количество сотрудников, реально числящихся в подразделении. Для реализации этого ограничения необходимо создать триггер, запускающийся при вставке, модификации и удалении записей в таблице PERSON, который корректно изменяет значение поля Dept\_Kol. Например, при вставке в таблицу PERSON новой строки, триггер увеличивает на единицу значение поля Dept\_Kol, а при удалении строки - уменьшает. Заметим, что при модификации записей в таблице PERSON могут потребоваться даже более сложные действия. Действительно, модификация записи в таблице PERSON может заключаться в том, что мы переводим сотрудника из одного отдела в другой, меняя значение в поле Dept\_Id. При этом необходимо в старом подразделении уменьшить количество сотрудников, а в новом - увеличить \autocite{TransCit}.

\paragraph{Внешний ключ} ~\\

\begin{grayquote}
    \textbf{Внешний ключ} – это ограничение целостности, в соответствии с которым множество значений внешнего ключа является подмножеством значений первичного или уникального ключа родительской таблицы \autocite{Karpova2009}.
\end{grayquote}

Ограничение целостности по внешнему ключу проверяется в двух случаях \autocite{Karpova2009}:

\begin{itemize}
    \item при добавлении записи в подчинённую таблицу СУБД проверяет, что в родительской таблице есть запись с таким же значением первичного ключа;
    \item при удалении записи из родительской таблицы СУБД проверяет, что в подчинённой таблице нет записей с таким же значением внешнего ключа.
\end{itemize}

\paragraph{Способы поддержания ссылочной целостности} ~\\
СУБД имеют механизм автоматического поддержания ссылочной целостности. Любая операция, изменяющая данные в таблице, вызывает автоматическую проверку ссылочной целостности. При этом \autocite{WikiLink}:

\begin{itemize}
    \item При операции добавления записи автоматически проверяется, ссылаются ли внешние ключи в этой записи на существующие записи в заявленных при описании связанных таблицах. Если выясняется, что операция приведёт к появлению некорректных ссылок, она не выполняется — система возвращает ошибку.
    
    \item При операции редактирования записи проверяется:
    \begin{itemize}
        \item если изменяется её первичный ключ и на данную запись имеются ссылки, то операция редактирования завершается с ошибкой;
        \item если изменяется какой-то из внешних ключей, хранящихся в этой записи, и после изменения внешний ключ будет ссылаться на несуществующую запись, то операция редактирования завершается с ошибкой.
    \end{itemize}
    
    \item При операции удаления записи проверяется, нет ли на неё ссылок. Если ссылки имеются, то возможно три варианта дальнейших действий (фактически выполняемый зависит от СУБД и от выбора программиста, который он должен сделать при описании связи):
    \begin{itemize}
        \item Запрет — удаление блокируется и возвращается ошибка.
        \item Каскадное удаление — в одной транзакции производится удаление данной записи и всех записей, ссылающихся на данную. Если на удаляемые записи также есть ссылки и настройки также требуют удаления, то каскадное удаление продолжается дальше. Таким образом, после удаления данной записи в базе не остаётся ни одной записи, прямо или косвенно ссылающейся на неё. Если хотя бы одну из ссылающихся записей удалить не получается (либо для неё настроен запрет, либо происходит какая-либо ещё ошибка), то все удаления запрещаются.
        \item Присвоение NULL — во все внешние ключи записей, ссылающихся на данную, записывается маркер NULL. Если хотя бы для одной из ссылающихся записей это невозможно (например, если поле внешнего ключа описано как NOT NULL), то удаление запрещается.
    \end{itemize}
\end{itemize}

\subsection{Правила (триггеры)}
Триггеры являются одной из разновидностей хранимых процедур. Их исполнение происходит при выполнении для таблицы какого-либо оператора языка манипулирования данными (DML). Триггеры используются для проверки целостности данных, а также для отката транзакций.


Триггер представляет собой специальный тип хранимых процедур, запускаемых сервером автоматически при попытке изменения данных в таблицах, с которыми триггеры связаны. Каждый триггер привязывается к конкретной таблице. Все производимые им модификации данных рассматриваются как одна транзакция. В случае обнаружения ошибки или нарушения целостности данных происходит откат этой транзакции. Тем самым внесение изменений запрещается. Отменяются также все изменения, уже сделанные триггером.


Триггер представляет собой весьма полезное и в то же время опасное средство. Так, при неправильной логике его работы можно легко уничтожить целую базу данных, поэтому триггеры необходимо очень тщательно отлаживать.


В отличие от обычной подпрограммы, триггер выполняется неявно в каждом случае возникновения триггерного события, к тому же он не имеет аргументов. Приведение его в действие иногда называют запуском триггера \autocite{IntuitTrigg}

\paragraph{Цели использования правил} ~\\

С помощью триггеров достигаются следующие цели \autocite{IntuitTrigg}:
\begin{itemize}
    \item проверка корректности введенных данных и выполнение сложных ограничений целостности данных, которые трудно, если вообще возможно, поддерживать с помощью ограничений целостности, установленных для таблицы;
    \item выдача предупреждений, напоминающих о необходимости выполнения некоторых действий при обновлении таблицы, реализованном определенным образом;
    \item накопление аудиторской информации посредством фиксации сведений о внесенных изменениях и тех лицах, которые их выполнили;
    \item поддержка репликации.
\end{itemize}

\paragraph{Способы задания, моменты выполнения} ~\\

Создает триггер только владелец базы данных. Это ограничение позволяет избежать случайного изменения структуры таблиц, способов связи с ними других объектов и т.п.


Основной формат команды CREATE TRIGGER показан ниже:
\begin{verbatim}
<Определение_триггера>::=
  CREATE TRIGGER имя_триггера
  BEFORE | AFTER <триггерное_событие>
  ON <имя_таблицы>
  [REFERENCING
    <список_старых_или_новых_псевдонимов>]
  [FOR EACH { ROW | STATEMENT}]
  [WHEN(условие_триггера)]
  <тело_триггера>
\end{verbatim}

Триггерные события состоят из вставки, удаления и обновления строк в таблице. В последнем случае для триггерного события можно указать конкретные имена столбцов таблицы.

\begin{grayquote}
    \textbf{Триггер} – это процедура БД, которая привязана к конкретной таблице и вызывается автоматически при наступлении определённого события (добавления, удаления или модификации данных этой таблицы).
\end{grayquote}

В отличие от обычной подпрограммы, триггер выполняется неявно в каждом случае возникновения триггерного события, к тому же он не имеет аргументов. Приведение его в действие иногда называют запуском триггера.


Время запуска триггера определяется с помощью ключевых слов BEFORE ( триггер запускается до выполнения связанных с ним событий) или AFTER (после их выполнения).


Выполняемые триггером действия задаются для каждой строки ( FOR EACH ROW ), охваченной данным событием, или только один раз для каждого события ( FOR EACH STATEMENT ).


Обозначение <список\_старых\_или\_новых\_псевдонимов> относится к таким компонентам, как старая или новая строка ( OLD / NEW ) либо старая или новая таблица ( OLD TABLE / NEW TABLE ). Ясно, что старые значения не применимы для событий вставки, а новые – для событий удаления \autocite{IntuitTrigg}.

\subsection{События}

\paragraph{Назначение механизма событий} ~\\

Механизм событий в базе данных (database events) позволяет прикладным программам и серверу базы данных уведомлять другие программы о наступлении в базе данных определенного события и тем самым синхронизировать их работу \autocite{OSP}.

\paragraph{Сигнализаторы событий. Типы уведомлений о происхождении события. Компоненты механизма событий} ~\\

Операторы языка SQL, обеспечивающие уведомление, часто называют сигнализаторами событий в базе данных (database event alerters). Функции управления событиями целиком ложатся на сервер базы данных.


Механизм событий используется следующим образом. Вначале в базе данных для каждого события создается флажок, состояние которого будет оповещать прикладные программы о том, что некоторое событие имело место (оператор CREATE DBEVENT - СОЗДАТЬ СОБЫТИЕ). Далее во все прикладные программы, на ход выполнения которых может повлиять это событие, включается оператор REGISTER DBEVENT (ЗАРЕГИСТРИРОВАТЬ СОБЫТИЕ), который оповещает сервер базы данных, что данная программа заинтересована в получении сообщения о наступлении события. Теперь любая прикладная программа или процедура базы данных может вызвать событие оператором RAISE DBEVENT (ВЫЗВАТЬ СОБЫТИЕ). Как только событие произошло, каждая зарегистрированная программа может получить его, для чего должна запросить очередное сообщение из очереди событий (оператор GET DBEVENT - ПОЛУЧИТЬ СОБЫТИЕ) и запросить информацию о событии, в частности, его имя (оператор SQL INQUIRE\_SQL) \autocite{OSP}.
